/*.$file${.::qbluetoothParsing.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: bluetooth.qm
* File:  ${.::qbluetoothParsing.c}
*
* This code has been generated by QM 5.1.4 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::qbluetoothParsing.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qtbox.h"
#include "qpc.h"
#include "bsp.h"
#include "../common/ring.h"
#include <sys/syscall.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include <time.h>
#include "type.h"

Q_DEFINE_THIS_FILE

extern tRINGBUF *ptRing_Bluetooth;

/* Active object class -----------------------------------------------------*/
/*.$declare${AOs::BluetoothParsing} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothParsing} ................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QEQueue requestQueue;
    QEvt const * requestQSto[50];
    uint8_t msg_defered_cnt;
    uint8_t sleepReq;
} BluetoothParsing;

/* protected: */
static QState BluetoothParsing_initial(BluetoothParsing * const me, void const * const par);
static QState BluetoothParsing_normal(BluetoothParsing * const me, QEvt const * const e);
static QState BluetoothParsing_parsing(BluetoothParsing * const me, QEvt const * const e);
static QState BluetoothParsing_parsing_idle(BluetoothParsing * const me, QEvt const * const e);
static QState BluetoothParsing_parsing_busy(BluetoothParsing * const me, QEvt const * const e);
static QState BluetoothParsing_sleep(BluetoothParsing * const me, QEvt const * const e);
/*.$enddecl${AOs::BluetoothParsing} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


/* Local objects -----------------------------------------------------------*/
static BluetoothParsing l_BluetoothParsing; /* the single instance of the Table active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_BluetoothParsing = &l_BluetoothParsing.super; /* "opaque" AO pointer */


/*..........................................................................*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::BluetoothParsing_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothParsing_ctor} ...........................................*/
void BluetoothParsing_ctor(void) {
    BluetoothParsing *me = &l_BluetoothParsing;
    QEQueue_init(&me->requestQueue,
                 me->requestQSto, Q_DIM(me->requestQSto));
    QActive_ctor(&me->super, Q_STATE_CAST(&BluetoothParsing_initial));
}
/*.$enddef${AOs::BluetoothParsing_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::BluetoothParsing} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothParsing} ................................................*/
/*.${AOs::BluetoothParsing::SM} ............................................*/
static QState BluetoothParsing_initial(BluetoothParsing * const me, void const * const par) {
    /*.${AOs::BluetoothParsing::SM::initial} */
    me->sleepReq = 0;

    log_i("[%s] child thread lwpid = %u \n", MODULE, syscall(SYS_gettid));
    log_i("[%s] child thread tid = %u \n", MODULE, pthread_self());
    return Q_TRAN(&BluetoothParsing_normal);
}
/*.${AOs::BluetoothParsing::SM::normal} ....................................*/
static QState BluetoothParsing_normal(BluetoothParsing * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothParsing::SM::normal} */
        case Q_ENTRY_SIG: {
            me->sleepReq = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothParsing::SM::normal::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothParsing_parsing);
            break;
        }
        /*.${AOs::BluetoothParsing::SM::normal::COMM_NEWMSG} */
        case COMM_NEWMSG_SIG: {
            /* defer the new request event... */
            if (QActive_defer(&me->super, &me->requestQueue, e)) {
            }
            else {
                /* should never been here */
                //Q_ASSERT(0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothParsing::SM::normal::LPM_SLEEPREQ} */
        case LPM_SLEEPREQ_SIG: {
            log_i("[%s] state: normal, evt: LPM_SLEEPREQ \n", MODULE);
            me->sleepReq = 1;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothParsing::SM::normal::parsing} ...........................*/
static QState BluetoothParsing_parsing(BluetoothParsing * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothParsing::SM::normal::parsing::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothParsing_parsing_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothParsing_normal);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothParsing::SM::normal::parsing::parsing_idle} .............*/
static QState BluetoothParsing_parsing_idle(BluetoothParsing * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothParsing::SM::normal::parsing::parsing_idle} */
        case Q_ENTRY_SIG: {
            if (QActive_recall(&me->super, &me->requestQueue)) {
                log_d("[%s] state: parsing_idle, Request recalled \n", MODULE);
            }
            else {
                log_d("[%s] state: parsing_idle, No deferred requests \n", MODULE);

                if(1 == me->sleepReq) {
                    static const QEvt te = {LPM_SLEEPREQ_SIG, 0, 0};
                    QACTIVE_POST(&me->super, &te, (void*)0);
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothParsing::SM::normal::parsing::parsing_idle::COMM_NEWMSG} */
        case COMM_NEWMSG_SIG: {
            log_d("[%s] state: parsing_idle, evt: COMM_NEWMSG \n", MODULE);
            status_ = Q_TRAN(&BluetoothParsing_parsing_busy);
            break;
        }
        /*.${AOs::BluetoothParsing::SM::normal::parsing::parsing_idle::LPM_SLEEPREQ} */
        case LPM_SLEEPREQ_SIG: {
            log_i("[%s] state: normal, evt: LPM_SLEEPREQ \n", MODULE);

            status_ = Q_TRAN(&BluetoothParsing_sleep);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothParsing_parsing);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothParsing::SM::normal::parsing::parsing_busy} .............*/
static QState BluetoothParsing_parsing_busy(BluetoothParsing * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothParsing::SM::normal::parsing::parsing_busy} */
        case Q_ENTRY_SIG: {
            log_d("[%s] state: parsing_busy, entry \n", MODULE);
            int ret = COMM_handle_msg_Ring(ptRing_Comm);
            //Q_ASSERT(0 == ret);

            static const QEvt MsgDoneEvt = { COMM_PARSEDONE_SIG, 0U, 0U };
            QACTIVE_POST(&me->super, &MsgDoneEvt, me);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothParsing::SM::normal::parsing::parsing_busy::COMM_PARSEDONE} */
        case COMM_PARSEDONE_SIG: {
            log_d("[%s] state: parsing, evt: COMM_MSGDONE \n", MODULE);
            status_ = Q_TRAN(&BluetoothParsing_parsing_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothParsing_parsing);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothParsing::SM::sleep} .....................................*/
static QState BluetoothParsing_sleep(BluetoothParsing * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothParsing::SM::sleep} */
        case Q_ENTRY_SIG: {
            log_i("[%s] state: sleep, entry \n", MODULE);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothParsing::SM::sleep::LPM_WAKEUP} */
        case LPM_WAKEUP_SIG: {
            log_i("[%s] state: sleep, evt: LPM_WAKEUP \n", MODULE);
            me->sleepReq = 0;
            status_ = Q_TRAN(&BluetoothParsing_normal);
            break;
        }
        /*.${AOs::BluetoothParsing::SM::sleep::LPM_SMSWAKEUP} */
        case LPM_SMSWAKEUP_SIG: {
            log_i("[%s] state: sleep, evt: LPM_SMSWAKEUP \n", MODULE);
            status_ = Q_TRAN(&BluetoothParsing_normal);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::BluetoothParsing} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

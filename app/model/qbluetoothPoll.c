/*.$file${.::qbluetoothPoll.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: bluetooth.qm
* File:  ${.::qbluetoothPoll.c}
*
* This code has been generated by QM 5.1.4 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::qbluetoothPoll.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qtbox.h"
#include "qpc.h"
#include "bsp.h"
#include "../common/ring.h"
#include <sys/syscall.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include "type.h"

Q_DEFINE_THIS_FILE


extern tRINGBUF *ptRing_Bluetooth;

/* Active object class -----------------------------------------------------*/
/*.$declare${AOs::BluetoothPolling} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothPolling} ................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt timeEvt;
    int32_t fd;
    uint8_t buf[FRAME_SIZE];
    QEQueue requestQueue;
    QEvt const * requestQSto[100];
    uint8_t msg_defered_cnt;
} BluetoothPolling;

/* protected: */
static QState BluetoothPolling_initial(BluetoothPolling * const me, void const * const par);
static QState BluetoothPolling_sleep(BluetoothPolling * const me, QEvt const * const e);
static QState BluetoothPolling_normal(BluetoothPolling * const me, QEvt const * const e);
static QState BluetoothPolling_active(BluetoothPolling * const me, QEvt const * const e);
static QState BluetoothPolling_polling(BluetoothPolling * const me, QEvt const * const e);
static QState BluetoothPolling_err(BluetoothPolling * const me, QEvt const * const e);
static QState BluetoothPolling_idle(BluetoothPolling * const me, QEvt const * const e);
/*.$enddecl${AOs::BluetoothPolling} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

#define POLL_TOUT    (QTimeEvtCtr)(BSP_TICKS_PER_SEC)
#define PREPOLL_TOUT    (QTimeEvtCtr)(BSP_TICKS_PER_SEC * 1)
#define REPOLL_TOUT  (QTimeEvtCtr)(BSP_TICKS_PER_SEC / 10)

/* Local objects -----------------------------------------------------------*/
static BluetoothPolling l_BluetoothPolling; /* the single instance of the Table active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_BluetoothPolling = &l_BluetoothPolling.super; /* "opaque" AO pointer */


/*..........................................................................*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::BluetoothPolling_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothPolling_ctor} ...........................................*/
void BluetoothPolling_ctor(void) {
    BluetoothPolling *me = &l_BluetoothPolling;
    QEQueue_init(&me->requestQueue,
                 me->requestQSto, Q_DIM(me->requestQSto));
    QActive_ctor(&me->super, Q_STATE_CAST(&BluetoothPolling_initial));
}
/*.$enddef${AOs::BluetoothPolling_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::BluetoothPolling} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothPolling} ................................................*/
/*.${AOs::BluetoothPolling::SM} ............................................*/
static QState BluetoothPolling_initial(BluetoothPolling * const me, void const * const par) {
    /*.${AOs::BluetoothPolling::SM::initial} */
    QActive_subscribe(&me->super, LPM_SLEEPREQ_SIG);
    QActive_subscribe(&me->super, LPM_WAKEUP_SIG);
    QActive_subscribe(&me->super, LPM_SMSWAKEUP_SIG);


    log_i("[%s] child thread lwpid = %u \n", MODULE, syscall(SYS_gettid));
    log_i("[%s] child thread tid = %u \n", MODULE, pthread_self());
    return Q_TRAN(&BluetoothPolling_normal);
}
/*.${AOs::BluetoothPolling::SM::sleep} .....................................*/
static QState BluetoothPolling_sleep(BluetoothPolling * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothPolling::SM::sleep} */
        case Q_ENTRY_SIG: {
            log_i("[%s] state: sleep, entry \n", MODULE);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothPolling::SM::sleep::LPM_WAKEUP} */
        case LPM_WAKEUP_SIG: {
            log_i("[%s] state: sleep, evt: LPM_WAKEUP \n", MODULE);
            status_ = Q_TRAN(&BluetoothPolling_normal);
            break;
        }
        /*.${AOs::BluetoothPolling::SM::sleep::LPM_SMSWAKEUP} */
        case LPM_SMSWAKEUP_SIG: {
            log_i("[%s] state: sleep, evt: LPM_SMSWAKEUP \n", MODULE);
            status_ = Q_TRAN(&BluetoothPolling_normal);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothPolling::SM::normal} ....................................*/
static QState BluetoothPolling_normal(BluetoothPolling * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothPolling::SM::normal::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothPolling_idle);
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::LPM_SLEEPREQ} */
        case LPM_SLEEPREQ_SIG: {
            //QTimeEvt_armX(&me->sleepTimeEvt, SLEEPDELAY_TOUT, 0U);
            log_i("[%s] state: normal, evt: LPM_SLEEPREQ \n", MODULE);
            status_ = Q_TRAN(&BluetoothPolling_sleep);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothPolling::SM::normal::active} ............................*/
static QState BluetoothPolling_active(BluetoothPolling * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothPolling::SM::normal::active} */
        case Q_ENTRY_SIG: {
            //QTimeEvt_armX(&me->timeEvt, POLL_TOUT, POLL_TOUT);
            log_d("[%s] state: active, entry \n", MODULE);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::active} */
        case Q_EXIT_SIG: {
            // QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothPolling_polling);
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::active::COMM_READERR} */
        case COMM_READERR_SIG: {
            log_i("[%s] state: active, evt: COMM_READERR \n", MODULE);
            status_ = Q_TRAN(&BluetoothPolling_err);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothPolling_normal);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothPolling::SM::normal::active::polling} ...................*/
static QState BluetoothPolling_polling(BluetoothPolling * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothPolling::SM::normal::active::polling} */
        case Q_ENTRY_SIG: {
            //printf("[AO_CommPolling] state: polling");
            static u8 buf[FRAME_SIZE];
            static int nReadBytes = 0;
            static unsigned int loops = 0;


            nReadBytes = COMM_poll_msg(me->fd, buf, FRAME_SIZE);
            //printf("[AO_CommPolling] loops: %d, COMM_poll_msg, ret = %d ", loops, nReadBytes);

            if(nReadBytes < 0) {
                static const QEvt CommReadEvt = { COMM_READERR_SIG, 0U, 0U };
                QACTIVE_POST(&me->super, &CommReadEvt, me);
            }
            else if(nReadBytes == 0) {
            //    printf("[AO_CommPolling] nReadBytes = 0 ");
            //    QTimeEvt_armX(&me->timeEvt, REPOLL_TOUT, 0);
            }
            else {
            #if 1
                log_d("[%s] state: polling, Get MSG, data: \n", MODULE);
                PrintHex(me->buf, nReadBytes);
            #endif

                int ret = RING_Attach_Data(ptRing_Comm, buf, nReadBytes);
                //Q_ASSERT(0 == ret);
                if(ret == 0) {
                    /* 检查是否收到帧结束符'\n' */
                    for(int n = 0; n < nReadBytes; n++) {
                        if(buf[n] == '\n') {
                            me->msg_defered_cnt ++;
                            static const QEvt NewMsgEvt = { COMM_NEWMSG_SIG, 0U, 0U };
                            QACTIVE_POST(AO_CommParsing, &NewMsgEvt, me);
                        }
                    }
                }

            }


            static const QEvt evt_1 = { COMM_POLLING_SIG, 0U, 0U };
            QACTIVE_POST(&me->super, &evt_1, me);




            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::active::polling} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::active::polling::COMM_POLLING} */
        case COMM_POLLING_SIG: {
            status_ = Q_TRAN(&BluetoothPolling_polling);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothPolling_active);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothPolling::SM::normal::err} ...............................*/
static QState BluetoothPolling_err(BluetoothPolling * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothPolling::SM::normal::err} */
        case Q_ENTRY_SIG: {
            printf("[AO_CommPolling] state: ERR ");

            QTimeEvt_armX(&me->timeEvt, POLL_TOUT, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::err} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothPolling::SM::normal::err::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&BluetoothPolling_active);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothPolling_normal);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothPolling::SM::normal::idle} ..............................*/
static QState BluetoothPolling_idle(BluetoothPolling * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothPolling::SM::normal::idle::COMM_POLLING} */
        case COMM_POLLING_SIG: {
            me->fd = Q_EVT_CAST(CommPollEvt)->fd;
            Q_ASSERT(me->fd > 0);
            log_d("[%s] state: idle, evt: COMM_POLLING, fd = %d \n", MODULE, me->fd);
            status_ = Q_TRAN(&BluetoothPolling_active);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothPolling_normal);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::BluetoothPolling} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

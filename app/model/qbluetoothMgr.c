/*.$file${.::qbluetoothMgr.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: bluetooth.qm
* File:  ${.::qbluetoothMgr.c}
*
* This code has been generated by QM 5.1.4 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::qbluetoothMgr.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "../common/ring.h"
#include <unistd.h>
#include <dirent.h>
#include "../comm/comm.h"
#include "assert.h"
#include <sys/syscall.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>
#include "bluetooth.h"

Q_DEFINE_THIS_FILE

/// 模块名
#define MODULE "AO_BluetoothMgr"

#define COMM_REQ_MAX  3

/* Active object class -----------------------------------------------------*/
/*.$declare${AOs::BluetoothMgr} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothMgr} ....................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QEQueue requestQueue;
    QEvt const * requestQSto[100];
    QTimeEvt timeEvt;
    uint8_t retry_times;
    int32_t fd;
    u8* pData;
    int32_t data_len;
    uint16_t block_amount;
    uint16_t block_id;
    uint8_t cmd_id;
    uint8_t target;
    uint8_t ack_flag;
    uint8_t resendLoops;
    uint32_t nBytesRemain;
    uint8_t sendRet;
    uint32_t nBytesWritten;
    uint8_t reackLoops;
    uint8_t task_id;
    uint8_t data_type;
} BluetoothMgr;

/* protected: */
static QState BluetoothMgr_initial(BluetoothMgr * const me, void const * const par);
static QState BluetoothMgr_active(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_testing(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_open(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_error(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_serving(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_send_single_frame(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_echoing_s(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_sending_s(BluetoothMgr * const me, QEvt const * const e);
static QState BluetoothMgr_idle(BluetoothMgr * const me, QEvt const * const e);
/*.$enddecl${AOs::BluetoothMgr} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

#define FREE      ((uint8_t)0)
#define USED      ((uint8_t)1)

#define BSP_TICKS_PER_SEC 100U

#define OPEN_TOUT       (QTimeEvtCtr)(BSP_TICKS_PER_SEC * 1)
#define TEST_TOUT       (QTimeEvtCtr)(BSP_TICKS_PER_SEC * 0.1)
#define RESEND_TIME     (QTimeEvtCtr)(BSP_TICKS_PER_SEC * 3)
#define ECHO_TOUT       (QTimeEvtCtr)(BSP_TICKS_PER_SEC * 3)

#define COMMOPEN_TIMES        3
#define ECHO_TIMES            3
#define TEST_MAXLOOPS         100
#define RESEND_MAXTIMES       3
#define ACK_MAXTIMES          3
#define RESEND_TIMES          3

/* Local objects -----------------------------------------------------------*/
static BluetoothMgr l_BluetoothMgr; /* the single instance of the Table active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_BluetoothMgr = &l_BluetoothMgr.super; /* "opaque" AO pointer */

/*..........................................................................*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::BluetoothMgr} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothMgr} ....................................................*/
/*.${AOs::BluetoothMgr::SM} ................................................*/
static QState BluetoothMgr_initial(BluetoothMgr * const me, void const * const par) {
    /*.${AOs::BluetoothMgr::SM::initial} */
    me->fd = -1;
    me->retry_times = 0;
    return Q_TRAN(&BluetoothMgr_active);
}
/*.${AOs::BluetoothMgr::SM::active} ........................................*/
static QState BluetoothMgr_active(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothMgr_testing);
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::BT_SEND} */
        case BT_SEND_SIG: {
            printf("\n[AO_CommMgr] state: active EVT: BT_SEND");

            /* defer the new request event... */
            if (QActive_defer(&me->super, &me->requestQueue, e)) {

                printf("[AO_CommMgr] defered cmd[#%d]",  (int)Q_EVT_CAST(BluetoothSendEvt)->cmd_id);
            }
            else {
                /* notify the request sender that his request was denied... */
                printf("[%s] WARNING!!! requestQueue is full, and will not accept new send request", MODULE);
                printf("[AO_CommMgr] Request #%d IGNORED;\n",
                       (int)Q_EVT_CAST(BluetoothSendEvt)->cmd_id);

                /* should never been here */
                //Q_ASSERT(0);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::testing} ...............................*/
static QState BluetoothMgr_testing(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::testing} */
        case Q_ENTRY_SIG: {
            me->retry_times = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::testing} */
        case Q_EXIT_SIG: {
            me->retry_times = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::testing::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothMgr_open);
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::testing::BT_SENDERR} */
        case BT_SENDERR_SIG: {
            status_ = Q_TRAN(&BluetoothMgr_error);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_active);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::testing::open} .........................*/
static QState BluetoothMgr_open(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::testing::open} */
        case Q_ENTRY_SIG: {
            if(me->fd < 0) {
                me->fd = COMM_open_dev();
            }

            if(me->fd < 0) {
                QTimeEvt_armX(&me->timeEvt, OPEN_TOUT, 0U);
            }
            else
            {
                static const QEvt evt = { BT_OPENOK_SIG, 0U, 0U };
                QACTIVE_POST(&me->super, &evt, me);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::testing::open} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::testing::open::TIMEOUT} */
        case TIMEOUT_SIG: {
            me->retry_times++;
            /*.${AOs::BluetoothMgr::SM::active::testing::open::TIMEOUT::[未超过次数]} */
            if (me->retry_times < COMMOPEN_TIMES) {
                status_ = Q_TRAN(&BluetoothMgr_open);
            }
            /*.${AOs::BluetoothMgr::SM::active::testing::open::TIMEOUT::[else]} */
            else {
                status_ = Q_TRAN(&BluetoothMgr_error);
            }
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::testing::open::BT_OPENOK} */
        case BT_OPENOK_SIG: {
            /* notify comm is ready for polling msg */
            //CommPollEvt *pe = Q_NEW(CommPollEvt, COMM_POLLING_SIG);
            //pe->fd = me->fd;
            //QACTIVE_POST(AO_CommPolling, &pe->super, me);
            status_ = Q_TRAN(&BluetoothMgr_serving);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_testing);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::error} .................................*/
static QState BluetoothMgr_error(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::error} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->timeEvt, TEST_TOUT, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::error} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::error::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&BluetoothMgr_active);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_active);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::serving} ...............................*/
static QState BluetoothMgr_serving(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::serving} */
        case Q_ENTRY_SIG: {
            Q_ASSERT(me->fd > 0);
            printf("\n[AO_CommMgr] state: serving");
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothMgr_idle);
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::BT_SENDERR} */
        case BT_SENDERR_SIG: {
            printf("\n[AO_CommMgr] state: sending_s, evt: BT_SENDERR");
            //BluetoothSendRetEvt *pe = Q_NEW(BluetoothSendRetEvt, BT_SENDERR_SIG);
            //if(pe) {
            //    pe->id = me->task_id;
            //    QACTIVE_POST(AO_NetTask[me->task_id], &pe->super, (void*)0);
            //}
            status_ = Q_TRAN(&BluetoothMgr_error);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_active);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::serving::send_single_frame} ............*/
static QState BluetoothMgr_send_single_frame(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_frame} */
        case Q_ENTRY_SIG: {
            me->retry_times = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&BluetoothMgr_sending_s);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_serving);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s}*/
static QState BluetoothMgr_echoing_s(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s} */
        case Q_ENTRY_SIG: {
            printf("[%s] state: echoing_s", MODULE);
            QTimeEvt_armX(&me->timeEvt, ECHO_TOUT, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s::TIMEOUT} */
        case TIMEOUT_SIG: {
            me->retry_times ++;
            /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s::TIMEOUT::[me->retry_times<ECHO_TIMES]} */
            if (me->retry_times < ECHO_TIMES) {
                status_ = Q_TRAN(&BluetoothMgr_sending_s);
            }
            /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s::TIMEOUT::[else]} */
            else {
                status_ = Q_TRAN(&BluetoothMgr_idle);
            }
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s::BT_ECHOED} */
        case BT_ECHOED_SIG: {
            printf("[%s] state: echoing_s, evt: BT_ECHOED", MODULE);
            BluetoothEchoEvt *pe = Q_EVT_CAST(BluetoothEchoEvt);
            /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s::BT_ECHOED::[pe->cmd_id==me->cmd_id]} */
            if (pe->cmd_id == me->cmd_id) {
                BluetoothEchoEvt *pe = Q_NEW(BluetoothEchoEvt, BT_ECHOED_SIG);
                pe->cmd_id = me->cmd_id;
                //if((me->task_id >= 0) && (me->task_id < N_TASK)) {
                //    QACTIVE_POST(AO_NetTask[me->task_id], &pe->super, (void*)0);
                //}
                status_ = Q_TRAN(&BluetoothMgr_idle);
            }
            /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::echoing_s::BT_ECHOED::[mismatch]} */
            else {
                printf("[%s] state: echoing_s, evt: BT_ECHOED, err: CMD MIS-MATCHED", MODULE);
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_send_single_frame);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::sending_s}*/
static QState BluetoothMgr_sending_s(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::sending_s} */
        case Q_ENTRY_SIG: {

            printf("\n[AO_CommMgr] state: sending_s, data_type = %d, cmd = %02x,", me->data_type, me->cmd_id);

            int ret = COMM_Send_Data(me->fd,
                                    me->data_type,
                                    me->task_id,
                                    me->cmd_id,
                                    me->target,
                                    me->ack_flag,
                                    me->pData,
                                    me->data_len);

            if(ret == 0) {
                QACTIVE_POST(&me->super, Q_NEW(QEvt, BT_SENDOK_SIG), (void*)0);
            } else {
                QACTIVE_POST(&me->super, Q_NEW(QEvt, BT_SENDERR_SIG), (void*)0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::sending_s::BT_SENDOK} */
        case BT_SENDOK_SIG: {
            printf("[AO_CommMgr] state: sending_s, evt: BT_SENDOK");
            /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::sending_s::BT_SENDOK::[(me->task_id<10)&&(me->ack_flag~} */
            if ((me->task_id < 10) && (me->ack_flag == 0xFE)) {
                status_ = Q_TRAN(&BluetoothMgr_echoing_s);
            }
            /*.${AOs::BluetoothMgr::SM::active::serving::send_single_fram~::sending_s::BT_SENDOK::[else]} */
            else {
                status_ = Q_TRAN(&BluetoothMgr_idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_send_single_frame);
            break;
        }
    }
    return status_;
}
/*.${AOs::BluetoothMgr::SM::active::serving::idle} .........................*/
static QState BluetoothMgr_idle(BluetoothMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::BluetoothMgr::SM::active::serving::idle} */
        case Q_ENTRY_SIG: {
            me->retry_times = 0;
            me->resendLoops = 0;

            printf("\n[AO_BluetoothMgr] state: idle");

            /* recall the oldest deferred request... */
            if (QActive_recall(&me->super, &me->requestQueue)) {
                printf("Request recalled\n");
            }
            else {
                printf("No deferred requests\n");
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::BluetoothMgr::SM::active::serving::idle::BT_SEND} */
        case BT_SEND_SIG: {
            printf("\n[AO_BluetoothMgr] state: idle EVT: BT_SEND");

            BluetoothSendEvt* pe = Q_EVT_CAST(BluetoothSendEvt);
            me->task_id = pe->task_id;
            me->data_type = pe->data_type;
            me->cmd_id = pe->cmd_id;
            me->ack_flag = pe->ack_flag;
            me->target = pe->target;
            me->pData = pe->data;
            me->data_len = pe->data_len;
            status_ = Q_TRAN(&BluetoothMgr_send_single_frame);
            break;
        }
        default: {
            status_ = Q_SUPER(&BluetoothMgr_serving);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::BluetoothMgr} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::BluetoothMgr_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::BluetoothMgr_ctor} ...............................................*/
void BluetoothMgr_ctor(void) {
    BluetoothMgr *me = &l_BluetoothMgr;
    QActive_ctor(&me->super, Q_STATE_CAST(&BluetoothMgr_initial));
    QEQueue_init(&me->requestQueue,
                 me->requestQSto, Q_DIM(me->requestQSto));
    QTimeEvt_ctorX(&me->timeEvt, &me->super, TIMEOUT_SIG, 0U);
}
/*.$enddef${AOs::BluetoothMgr_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
